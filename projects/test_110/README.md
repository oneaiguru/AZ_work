# Interior Point Method PWA

В директории `projects/test_110/math-pwa` находится PWA-приложение, целиком
посвящённое экспериментам с методом внутренней точки для задач линейного
программирования. Стек соответствует ранее согласованным требованиям: Vue 3 +
Vite, Tailwind CSS, AssemblyScript/WebAssembly, PWA и контейнеризация через
Docker/Docker Swarm.

## Возможности

- Ввод задачи линейного программирования в каноническом виде \(\min c^T x\)
  при ограничениях \(Ax = b,\; x > 0\).
- Запуск реализации метода внутренней точки, написанной на AssemblyScript и
  исполняемой в браузере через WebAssembly.
- Просмотр сводки по решению: статус, число итераций, значения нормы остатка и
  вектора решения.
- График динамики целевой функции по итерациям.
- Нотификации об ошибках валидации и об успешном завершении расчёта.

## Формат ввода

- Матрица \(A\) задаётся строками, разделёнными переводом строки; элементы в
  строке разделяются пробелами.
- Векторы \(b\) и \(c\) вводятся в одну строку через пробел.
- Начальные приближения \(x_0\) и \(s_0\) опциональны. При отсутствии данных
  используются единичные векторы. Для ускорения сходимости рекомендуется задавать
  положительные значения, приблизительно удовлетворяющие ограничениям.
- Максимальное число итераций и порог остановки настраиваются через отдельные
  поля.

## Реализация метода внутренней точки (AssemblyScript)

Функция `interiorPointSolve` экспонируется из `src/wasm/assembly/index.ts` и
принимает следующие параметры:

```
interiorPointSolve(
  A: Float64Array,  // матрица размера m × n в «плоском» виде по строкам
  b: Float64Array,  // вектор длины m
  c: Float64Array,  // вектор длины n
  m: i32,           // число ограничений
  n: i32,           // число переменных
  maxIter: i32,     // максимум итераций
  tol: f64,         // порог остановки
  x0: Float64Array, // (опционально) начальное x
  s0: Float64Array  // (опционально) начальное s
): Float64Array
```

Алгоритм реализует барьерный (log-barrier) вариант метода внутренней точки с
прямо-двойственным поиском Ньютона и пошаговой защитой от выхода из допустимой
области. На каждой итерации вычисляется система уравнений Каруша—Куна—Таккера,
формируется матрица Шура и решается методом Гаусса. Для защиты от численных
проблем введено минимальное значение `1e-12` для элементов \(x\) и \(s\).

Возвращаемый массив включает:

1. Флаг успеха (1.0 — выполнены критерии останова, 0.0 — достигнут предел
   итераций).
2. Число итераций.
3. Финальное значение \(c^T x\).
4. Норма \(‖Ax - b‖_2\).
5. Норма \(‖A^T y + s - c‖_2\).
6. Далее — блоки по четыре числа для каждой итерации (целевое значение,
   комплементарность \(µ\), нормы праймального и дуального остатка).
7. В конце — компоненты найденного вектора \(x\).

Фронтенд извлекает статистику для вывода отчёта и построения графика.

## Структура проекта

```
projects/test_110/math-pwa/
├── asconfig.json
├── docker-compose.yml
├── Dockerfile
├── nginx.conf
├── package.json
├── postcss.config.cjs
├── public/
│   ├── icons/
│   │   ├── icon-192.base64
│   │   └── icon-512.base64
│   └── manifest.json
├── scripts/
│   └── decode-icons.mjs
├── src/
│   ├── App.vue
│   ├── components/
│   │   ├── GraphCanvas.vue
│   │   ├── MathForm.vue
│   │   ├── NotificationToast.vue
│   │   └── ResultCard.vue
│   ├── composables/
│   │   ├── useMathTasks.ts
│   │   ├── useMathWasm.ts
│   │   └── useNotifications.ts
│   ├── main.ts
│   ├── styles/
│   │   └── tailwind.css
│   └── wasm/
│       ├── assembly/
│       │   ├── index.ts
│       │   └── tsconfig.json
│       └── tests/
│           └── integration.spec.ts
├── tailwind.config.cjs
├── tsconfig.app.json
├── tsconfig.json
└── vite.config.ts
```

## Запуск и сборка

```bash
cd projects/test_110/math-pwa
npm install
npm run decode:icons  # шаг выполняется автоматически в npm-скриптах, но можно запустить вручную
npm run asbuild
npm run dev
```

Для production-сборки и предпросмотра:

```bash
npm run build
npm run decode:icons  # при необходимости пересоздаёт иконки из base64-версий
npm run preview
```

### Docker

```bash
docker build -t interior-point-pwa .
docker run -p 8080:80 interior-point-pwa
```

### Docker Swarm

```bash
docker swarm init
docker stack deploy -c docker-compose.yml ip-lab
```

## План дальнейшего развития

### Этап 0. Подготовка и проектирование (1 день)
- Финализация пользовательских сценариев: решение одной задачи, пакетная
  обработка, сохранение входных данных.
- Уточнение требований к визуализации (остатки, дуальная оценка, журнал шагов).

### Этап 1. AssemblyScript + WASM (2 дня)
- Дополнение алгоритма предиктор-корректором (Mehrotra) и адаптивным выбором
  параметра центрации.
- Покрытие тестами крайних случаев (вырожденные ограничения, плохая начальная
  точка) через as-pect.
- Экспорт дополнительных метрик (вектор \(y\), slack-переменные).

### Этап 2. Фронтенд и UX (2–3 дня)
- Расширенные валидации и подсветка ошибок ввода.
- Табличное отображение истории итераций с возможностью экспорта в CSV.
- Переключатели графиков (целевое значение, нормы остатка, комплементарность).

### Этап 3. PWA (1 день)
- Настройка офлайн-кэша только для релевантных ресурсов.
- Добавление страницы «Справка» с описанием метода и примерами.

### Этап 4. Docker и Swarm (1 день)
- CI/CD для автоматической сборки образа и выкладки стека.
- Настройка health-check и логирования в Swarm.

### Этап 5. Документация и финальное тестирование (1 день)
- Гайды по подготовке данных, шаблоны задач.
- Проверка в Lighthouse (PWA ≥ 90), e2e-скрипты для smoke-тестов.

Итого базовая дорожная карта занимает ~6 рабочих дней, не считая будущих
улучшений по алгоритмической части.
